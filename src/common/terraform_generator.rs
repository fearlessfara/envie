use crate::common::*;
use std::collections::HashMap;
use std::path::Path;

#[derive(Debug, Clone)]
pub struct TerraformGenerator {
    pub backend_config: BackendConfig,
}

#[derive(Debug, Clone)]
pub struct BackendConfig {
    pub backend_type: String,
    pub config: HashMap<String, String>,
}

impl Default for BackendConfig {
    fn default() -> Self {
        let mut config = HashMap::new();
        config.insert("bucket".to_string(), "terraform-state-bucket".to_string());
        config.insert("region".to_string(), "eu-west-1".to_string());
        config.insert("key".to_string(), "terraform.tfstate".to_string());
        
        Self {
            backend_type: "s3".to_string(),
            config,
        }
    }
}

impl TerraformGenerator {
    pub fn new() -> Self {
        Self {
            backend_config: BackendConfig::default(),
        }
    }
    
    pub fn with_backend(mut self, backend: BackendConfig) -> Self {
        self.backend_config = backend;
        self
    }
    
    pub fn generate_remote_state_data_sources(
        &self,
        module_path: &Path,
        dependencies: &[DependencyReference],
        environment_resolver: &EnvironmentResolver,
        environment_overrides: &std::collections::HashMap<String, String>,
        service_name: &str,
        module_name: &str,
    ) -> Result<String> {
        let mut generated = String::new();
        
        generated.push_str("# Auto-generated by Envie - DO NOT EDIT\n");
        generated.push_str("# This file is automatically generated and will be overwritten\n\n");
        
        // First, scan existing Terraform files to see what data sources are already used
        let scanner = TerraformScanner::new()?;
        let existing_deps = scanner.scan_directory(module_path)?;
        
        // Create a set of existing data source names to avoid duplicates
        let existing_names: std::collections::HashSet<String> = existing_deps
            .iter()
            .map(|dep| dep.data_source_name.clone())
            .collect();
        
        for dependency in dependencies {
            // Check for CLI override for this dependency
            let (source_service, source_module) = self.extract_service_module_from_source(&dependency.path)?;
            let environment_to_use = if let Some(override_env) = environment_overrides.get(&source_service) {
                override_env.clone()
            } else {
                dependency.environment.clone()
            };
            
            let resolved_env = environment_resolver.resolve_environment(&environment_to_use)?;
            
            // Generate a more descriptive name: service_module
            let data_source_name = if source_service == "current" {
                format!("{}_{}", service_name, source_module)
            } else {
                format!("{}_{}", source_service, source_module)
            };
            
            // Skip if this data source already exists
            if existing_names.contains(&data_source_name) {
                continue;
            }
            
            generated.push_str(&format!(
                r#"data "terraform_remote_state" "{}" {{
  backend = "{}"
  workspace = "{}"
  
  config = {{
"#,
                data_source_name,
                resolved_env.backend.backend_type,
                resolved_env.workspace
            ));
            
            let state_key = environment_resolver.generate_state_key(&resolved_env, &source_service, &source_module);
            for (key, value) in &resolved_env.backend.config {
                if key == "key_pattern" {
                    generated.push_str(&format!("    key = \"{}\"\n", state_key));
                } else {
                    generated.push_str(&format!("    {} = \"{}\"\n", key, value));
                }
            }
            
            generated.push_str("  }\n}\n\n");
        }
        
        Ok(generated)
    }
    
    fn extract_service_module_from_source(&self, source: &str) -> Result<(String, String)> {
        // Convert source path to service/module
        // e.g., "../database/modules/dynamodb" -> ("database", "dynamodb")
        // e.g., "./lambda" -> (current_service, "lambda")
        // e.g., "../../database/modules/dynamodb" -> ("database", "dynamodb")
        
        let normalized_source = source
            .replace("../", "")
            .replace("./", "")
            .replace("//", "/");
        
        let parts: Vec<&str> = normalized_source.split('/').collect();
        
        if parts.len() >= 2 {
            let service = parts[0].to_string();
            let module = parts[parts.len() - 1].to_string();
            Ok((service, module))
        } else if parts.len() == 1 {
            // Local module reference
            Ok(("current".to_string(), parts[0].to_string()))
        } else {
            Err(EnvieError::ValidationError(
                format!("Invalid source path: {}", source)
            ))
        }
    }
    
    fn generate_state_key(&self, source: &str, workspace: &str) -> Result<String> {
        // Convert source path to state key
        // e.g., "../database/modules/dynamodb" -> "database/dynamodb/terraform.tfstate"
        let normalized_source = source
            .replace("../", "")
            .replace("./", "")
            .replace("//", "/");
        
        Ok(format!("{}/terraform.tfstate", normalized_source))
    }
    
    
    pub fn write_generated_files(
        &self,
        module_path: &Path,
        dependencies: &[DependencyReference],
        module_config: &ModuleConfig,
        environment_resolver: &EnvironmentResolver,
        environment_overrides: &std::collections::HashMap<String, String>,
        service_name: &str,
        module_name: &str,
    ) -> Result<()> {
        // Generate and write remote state data sources
        let remote_state_content = self.generate_remote_state_data_sources(
            module_path,
            dependencies,
            environment_resolver,
            environment_overrides,
            service_name,
            module_name,
        )?;
        
        let remote_state_file = module_path.join(".envie-remote-state.tf");
        std::fs::write(remote_state_file, remote_state_content)?;
        
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct WorkspaceResolver {
    pub current_workspace: String,
    pub environment_overrides: HashMap<String, String>,
    pub service_registry: ServiceRegistry,
}

impl WorkspaceResolver {
    pub fn new(current_workspace: String, service_registry: ServiceRegistry) -> Self {
        Self {
            current_workspace,
            environment_overrides: HashMap::new(),
            service_registry,
        }
    }
    
    pub fn with_environment_overrides(mut self, overrides: HashMap<String, String>) -> Self {
        self.environment_overrides = overrides;
        self
    }
    
    pub fn resolve_workspace(&self, source: &str, explicit_workspace: Option<&str>) -> Result<String> {
        // If explicitly specified, use that
        if let Some(workspace) = explicit_workspace {
            return Ok(workspace.to_string());
        }
        
        // Check for environment overrides
        if let Some(workspace) = self.environment_overrides.get(source) {
            return Ok(workspace.clone());
        }
        
        // Try to resolve based on dependency graph
        if let Some(workspace) = self.resolve_from_dependency_graph(source)? {
            return Ok(workspace);
        }
        
        // Default to current workspace
        Ok(self.current_workspace.clone())
    }
    
    fn resolve_from_dependency_graph(&self, source: &str) -> Result<Option<String>> {
        // This is a simplified implementation
        // In a real implementation, you'd traverse the dependency graph
        // to determine which workspace the source should be in
        
        // For now, if it's a relative path (../), assume it's in a different workspace
        if source.starts_with("../") {
            // This would need more sophisticated logic to determine
            // which workspace the dependency is actually in
            return Ok(Some("sandbox".to_string())); // Placeholder
        }
        
        Ok(None)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs;

    #[test]
    fn test_remote_state_generation() {
        let generator = TerraformGenerator::new();
        let temp_dir = TempDir::new().unwrap();
        let module_path = temp_dir.path();
        
        let remote_states = vec![
            RemoteStateReference {
                name: "database".to_string(),
                source: "../database/modules/dynamodb".to_string(),
                workspace: Some("sandbox".to_string()),
                outputs: vec!["table_name".to_string(), "table_arn".to_string()],
            }
        ];
        
        let workspace_resolver = WorkspaceResolver::new(
            "myapp-123".to_string(),
            ServiceRegistry {
                services: HashMap::new(),
                modules: HashMap::new(),
            }
        );
        
        let generated = generator.generate_remote_state_data_sources(
            module_path,
            &remote_states,
            &workspace_resolver,
        ).unwrap();
        
        assert!(generated.contains("data \"terraform_remote_state\" \"database\""));
        assert!(generated.contains("workspace = \"sandbox\""));
        assert!(generated.contains("key = \"database/modules/dynamodb/terraform.tfstate\""));
    }
    
    #[test]
    fn test_module_variables_generation() {
        let generator = TerraformGenerator::new();
        
        let mut variables = HashMap::new();
        variables.insert("runtime".to_string(), serde_json::Value::String("nodejs18.x".to_string()));
        variables.insert("timeout".to_string(), serde_json::Value::Number(serde_json::Number::from(30)));
        variables.insert("memory".to_string(), serde_json::Value::Number(serde_json::Number::from(512)));
        
        let module_config = ModuleConfig {
            name: "lambda".to_string(),
            description: "Lambda function".to_string(),
            path: "modules/lambda".to_string(),
            depends: vec![],
            remote_states: vec![],
            variables,
        };
        
        let generated = generator.generate_module_variables(&module_config).unwrap();
        
        assert!(generated.contains("variable \"runtime\""));
        assert!(generated.contains("default = \"nodejs18.x\""));
        assert!(generated.contains("variable \"timeout\""));
        assert!(generated.contains("default = 30"));
    }
}
