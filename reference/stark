#!/bin/bash
set -e

# Color codes
GRAY="\033[1;30m"
GREEN="\033[32m"
YELLOW="\033[33m"
RED="\033[31m"
RESET="\033[0m"

# Function to handle script output messages
print_msg() {
  echo -e "$@"
}

# Functions to print messages with colors
print_gray() {
  print_msg "${GRAY}$@${RESET}"
}

print_green() {
  print_msg "${GREEN}$@${RESET}"
}

print_yellow() {
  print_msg "${YELLOW}$@${RESET}"
}

print_red() {
  print_msg "${RED}$@${RESET}"
}

# Defaults
ENV_FILE=".env.example"
TF_OUTPUT_FILE="../cli/.arya/output.json"

# This flag determines whether we call `arya output` or use a file
USE_ARYA_OUTPUT=true

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --env-file)
      ENV_FILE="$2"
      shift 2
      ;;
    --file)
      # We won't call `arya output` anymore
      USE_ARYA_OUTPUT=false

      # Check if next argument is missing or a new flag
      if [[ -z "$2" || "$2" =~ ^- ]]; then
        # If there's no file specified, we stick to the default TF_OUTPUT_FILE
        shift
      else
        # Otherwise, use the provided file
        TF_OUTPUT_FILE="$2"
        shift 2
      fi
      ;;
    *)
      shift
      ;;
  esac
done

#############################################
# LOGIC: If USE_ARYA_OUTPUT => call arya output
#############################################
if $USE_ARYA_OUTPUT; then
  print_yellow "Calling \`arya output\`..."
  terraform_output=$(arya output)
  if [[ $? -ne 0 || -z "$terraform_output" ]]; then
    print_red "Error: Failed to retrieve Terraform outputs using 'arya output'."
    exit 1
  fi
else
  print_yellow "Reading Terraform outputs from: $TF_OUTPUT_FILE"
  if [[ ! -f "$TF_OUTPUT_FILE" ]]; then
    print_red "Error: File '$TF_OUTPUT_FILE' does not exist."
    exit 1
  fi
  terraform_output=$(< "$TF_OUTPUT_FILE")
  if [[ -z "$terraform_output" ]]; then
    print_red "Error: Failed to read data from '$TF_OUTPUT_FILE'."
    exit 1
  fi
fi

#############################################
# PARSE $ENV_FILE
#############################################
print_yellow "Parsing $ENV_FILE ..."
if [[ ! -f "$ENV_FILE" ]]; then
  print_red "Error: Environment file '$ENV_FILE' does not exist."
  exit 1
fi

example_vars=()
while IFS='=' read -r key value; do
  # Skip lines without '=' or blank lines
  [[ -z "$key" || -z "$value" ]] && continue

  # Remove quotes
  value=$(echo "$value" | tr -d '"')

  # Handle hierarchical references
  IFS='.' read -r first_key remaining_path <<< "$value"
  if [[ -n "$remaining_path" ]]; then
    terraform_var="$first_key.$remaining_path"
  else
    terraform_var="$first_key.value"
  fi

  # Extract from JSON
  terraform_value=$(echo "$terraform_output" | jq -r ".$terraform_var")
  if [[ -z "$terraform_value" || "$terraform_value" == "null" ]]; then
    print_yellow "Warning: Failed to parse $key(=$value) from Terraform outputs."
  else
    example_vars+=("$key=\"$terraform_value\"")
  fi
done < <(sed -e '$a\' "$ENV_FILE")

#############################################
# WRITE .env
#############################################
# Check if running in CI, and don't clear .env
if [[ -n "$CI_PIPELINE_URL" ]]; then
  print_yellow "Running in CI, skipping .env clearing..."
else
  print_yellow "Clearing .env..."
  > .env
fi

print_yellow "Generating .env..."
for var in "${example_vars[@]}"; do
  echo "$var" >> .env
done

print_green "Success: .env has been generated successfully!"
